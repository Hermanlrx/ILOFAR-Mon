<!DOCTYPE html>
<html>
<head>
    <title>ILOFAR Dynamic Spectrogram</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        #plot { 
            width: 100%; 
            height: 720px; 
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 5px;
        }
        .control-group {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 150px;
        }
        input[type="range"] {
            cursor: pointer;
        }
        select {
            padding: 5px;
            background: #3a3a3a;
            color: #fff;
            border: 1px solid #555;
            border-radius: 3px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background: #357abd; }
        .info {
            margin: 10px 0;
            padding: 10px;
            background: #2a2a2a;
            border-left: 3px solid #4a90e2;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>ILOFAR Mode 357 Spectrogram Viewer</h1>
    
    <div id="info" class="info">Loading data...</div>
    
    <div class="controls">
        <div class="control-group">
            <label>Start Time: <span id="startTimeLabel">0 min</span></label>
            <input type="range" id="startMin" value="0" min="0" step="1" style="width: 300px;" oninput="debouncedUpdate()">
        </div>
        <div class="control-group">
            <label>Duration: <span id="durationLabel">60 min</span></label>
            <input type="range" id="duration" value="60" min="1" step="1" max="120" style="width: 300px;" oninput="debouncedUpdate()">
        </div>
        <div class="control-group">
            <label>Colormap:</label>
            <select id="colormap" onchange="debouncedUpdate()">
                <option value="Viridis">Viridis</option>
                <option value="Plasma">Plasma</option>
                <option value="Inferno">Inferno</option>
                <option value="Hot">Hot</option>
                <option value="Jet">Jet</option>
            </select>
        </div>
        <div class="control-group">
            <label>Gamma: <span id="gammaLabel">0.9</span></label>
            <input type="range" id="gamma" value="0.9" min="0.1" max="2" step="0.05" style="width: 300px;" oninput="debouncedUpdate()">
        </div>
        <button onclick="resetView()">Reset View</button>
    </div>
    
    <div id="plot"></div>
    
    <script>
        let spectrogramData = null;
        let debounceTimer = null;
        
        async function loadData() {
            try {
                const response = await fetch('./latest_spectrogram.json');
                spectrogramData = await response.json();
                
                const meta = spectrogramData.metadata;
                document.getElementById('info').innerHTML = `
                    <strong>File:</strong> ${meta.original_file} | 
                    <strong>Start:</strong> ${new Date(meta.start_time).toISOString()} | 
                    <strong>Duration:</strong> ${(meta.duration_seconds / 60).toFixed(1)} min | 
                    <strong>Samples:</strong> ${meta.num_time_samples}
                `;
                
                document.getElementById('duration').max = Math.ceil(meta.duration_seconds / 60);
                document.getElementById('startMin').max = Math.ceil(meta.duration_seconds / 60);
                updatePlot();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('info').innerHTML = 
                    '<strong style="color: #ff6b6b;">Error loading data. Check console.</strong>';
            }
        }
        
        // Process raw intensity data: log scale → background division
        function processData(data) {
            // Step 1: Convert to log10 scale (floor at 1e-10 to avoid log(0))
            const logData = data.map(row => 
                row.map(val => Math.log10(Math.max(val, 1e-10)))
            );
            
            // Step 2: Replace any NaN/Inf values with 0
            logData.forEach(row => {
                for (let i = 0; i < row.length; i++) {
                    if (!isFinite(row[i])) row[i] = 0;
                }
            });
            
            // Step 3: Divide each frequency row by its median (background subtraction)
            const flattened = logData.map(row => {
                const sorted = [...row].sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)];
                const bg = median === 0 ? 1.0 : median;
                return row.map(val => val / bg);
            });
            
            return flattened;
        }
        
        // Apply power-law normalization with gamma correction for contrast
        function applyPowerNorm(data, vmin, vmax, gamma) {
            const range = vmax - vmin || 1;
            return data.map(row =>
                row.map(val => {
                    // Clip to [vmin, vmax] range
                    const clipped = Math.max(vmin, Math.min(vmax, val));
                    // Normalize to [0, 1]
                    const normalized = (clipped - vmin) / range;
                    // Apply gamma power law
                    return Math.pow(normalized, gamma);
                })
            );
        }
        
        function debouncedUpdate() {
            // Update labels immediately for instant feedback
            const startMin = parseFloat(document.getElementById('startMin').value);
            const duration = parseFloat(document.getElementById('duration').value);
            const gamma = parseFloat(document.getElementById('gamma').value);
            
            document.getElementById('startTimeLabel').textContent = `${startMin} min`;
            document.getElementById('durationLabel').textContent = `${duration} min`;
            document.getElementById('gammaLabel').textContent = gamma.toFixed(2);
            
            // Debounce the expensive plot update
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                updatePlot();
            }, 150);
        }
        
        function updatePlot() {
            if (!spectrogramData) return;
            
            // Get current control values
            const startMin = parseFloat(document.getElementById('startMin').value);
            const duration = parseFloat(document.getElementById('duration').value);
            const colormap = document.getElementById('colormap').value;
            const gamma = parseFloat(document.getElementById('gamma').value);
            
            // Convert timestamps to Date objects
            const times = spectrogramData.timestamps.map(t => new Date(t));
            
            // Calculate time window indices (1 sample per second)
            const i0 = Math.floor(startMin * 60);
            const i1 = Math.min(i0 + Math.floor(duration * 60), times.length);
            
            const bands = spectrogramData.bands;
            const traces = [];
            
            // Process each band: slice time window → log/background processing
            const dividedBands = bands.map(band => {
                const sliced = band.data.map(row => row.slice(i0, i1));
                return processData(sliced);
            });
            
            // Calculate vmin/vmax from ALL bands combined (30th and 95th percentiles)
            const allData = dividedBands.flatMap(band => band.flat());
            allData.sort((a,b) => a - b);
            const refVmin = allData[Math.floor(allData.length * 0.30)] ?? 0;
            const refVmax = allData[Math.floor(allData.length * 0.95)] ?? 1;
            
            // Apply gamma normalization to all bands using global limits
            const processedBands = dividedBands.map(divided => 
                applyPowerNorm(divided, refVmin, refVmax, gamma)
            );
            
            // Create heatmap trace for each band (Mode 3, 5, 7)
            processedBands.forEach((zdata, idx) => {
                traces.push({
                    z: zdata,
                    x: times.slice(i0, i1),
                    y: bands[idx].frequencies,
                    type: 'heatmap',
                    colorscale: colormap,
                    zmin: 0,
                    zmax: 1,
                    zsmooth: false,
                    showscale: idx === 2,  // Only show colorbar for bottom panel
                    colorbar: idx === 2 ? {
                        title: { text: 'Normalized Intensity', side: 'right' },
                        x: 1.02,
                        y: 0.5,
                        len: 0.92,
                        thickness: 20,
                        tickfont: { size: 11 }
                    } : undefined,
                    xaxis: `x${idx + 1}`,
                    yaxis: `y${idx + 1}`,
                    hovertemplate: '<b>%{y:.2f} MHz</b><br>%{x|%H:%M:%S}<br>I: %{z:.3f}<extra></extra>'
                });
            });
            
            // Layout: 3 stacked panels with shared time axis
            const layout = {
                title: {
                    text: `ILOFAR Mode 357 - ${times[i0].toISOString().split('T')[1].slice(0,5)} to ${times[i1-1].toISOString().split('T')[1].slice(0,5)} UTC`,
                    font: { size: 16 }
                },
                xaxis:  { showticklabels: false, domain: [0, 0.96] },
                xaxis2: { showticklabels: false, domain: [0, 0.96] },
                xaxis3: { 
                    title: 'Time (UTC)',
                    tickformat: '%H:%M',
                    domain: [0, 0.96]
                },
                // Vertical panel layout: Mode 3 (top 35%), Mode 5 (middle 35%), Mode 7 (bottom 20%)
                yaxis:  { title: 'Mode 3 (MHz)', autorange: 'reversed', domain: [0.65, 1.000] },
                yaxis2: { title: 'Mode 5 (MHz)', autorange: 'reversed', domain: [0.25, 0.60] },
                yaxis3: { title: 'Mode 7 (MHz)', autorange: 'reversed', domain: [0.000, 0.20] },
                plot_bgcolor: '#1a1a1a',
                paper_bgcolor: '#2a2a2a',
                font: { color: '#fff' },
                hovermode: 'closest',
                height: 520,
                margin: { l: 65, r: 90, t: 50, b: 70 },
                grid: { rows: 3, columns: 1, pattern: 'independent' }
            };
            
            Plotly.newPlot('plot', traces, layout);
        }
        
        function resetView() {
            document.getElementById('startMin').value = 0;
            document.getElementById('duration').value = 60;
            document.getElementById('gamma').value = 0.9;
            updatePlot();
        }
        
        loadData();
    </script>
</body>
</html>